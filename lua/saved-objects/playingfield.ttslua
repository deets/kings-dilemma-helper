#include kd/util.ttslua
#include kd/common.ttslua

VOTE_COUNT_PERIOD = 5

voting_area_location = Vector(0, 0, 0.42)
voting_area_extend = Vector(1, 0.15, 0)

function influence_markers_in_voting_area()
    return refineTableBy(
        upCast(self, 10, voting_area_location, voting_area_extend),
        filter_influence_markers
    )
end

function resolve(_, vote)
    local ims = influence_markers_in_voting_area()
    local im_count = sum_value(ims)
    local pms = get_all_player_mats()
    local pass_for_power = {}
    for _, player_mat in pairs(pms) do
        local g = player_mat.getGUID()
        if player_mat.call("voted_for_power", {}) then
            log(g, "voted for power")
            table.insert(pass_for_power, g)
        end
    end

    if #pass_for_power > 0 and #ims > 0 then
        local influence_to_distribute = math.floor((im_count - (im_count % #pass_for_power)) / #pass_for_power)
        log(#pass_for_power, "players voting for power: ")
        log(influence_to_distribute, "influence per player: ")
        local current_influence_marker = table.remove(ims, 1)
        for _, pm_guid in pairs(pass_for_power) do
            local pillepalle = getObjectFromGUID(pm_guid)
            local ppos = pillepalle.call("influence_placement_position", { gain=influence_to_distribute }) +  Vector(0, 3, 0)
            for i=1, influence_to_distribute do
                if current_influence_marker.getQuantity()  == -1 then
                    current_influence_marker.setPositionSmooth(ppos, false, false)
                    -- guard against over-drawing
                    if #ims > 0 then
                        current_influence_marker = table.remove(ims, 1)
                    end
                else -- we have a stack
                    local tp = {
                        position = Vector(ppos),
                    }
                    current_influence_marker.takeObject(tp)
                end
                ppos = ppos + STACKING
            end
        end
    end
    -- always collect the money, it could be for power or arbittraion
    for _, pm in pairs(get_all_player_mats()) do
        pm.call("collect_pass_money", {})
    end
    local cpos = self.getPosition() + rotated(voting_area_location, self.getRotation()) + STACKING
    for _, thingamabob in pairs(get_all_player_mats()) do
        cpos = thingamabob.call("collect_votes", { vote=vote, position=cpos  })
    end
end

function count_votes()
   local yes_votes = 0
   local no_votes = 0
   local pms = get_all_player_mats()
   for _, player_mat in pairs(pms) do
      local voting_state = player_mat.call("voting_state", {})
      yes_votes = yes_votes + voting_state.yes
      no_votes = no_votes + voting_state.no
      local sigil = PLAYERMAT_TO_SIGIL[voting_state.mat]
      if sigil then
         getObjectFromGUID(sigil).call("set_vote_count", voting_state.yes + voting_state.no)
      end
   end
   return { yes_votes=yes_votes, no_votes=no_votes }
end

function display_vote_count()
   local vc  = count_votes()
   self.UI.setValue("yes_vote_count", "" .. vc.yes_votes)
   self.UI.setValue("no_vote_count", "" .. vc.no_votes)
end

function onLoad()
   function periodic_vote_counter()
      display_vote_count()
      after(VOTE_COUNT_PERIOD, periodic_vote_counter)
   end
   after(VOTE_COUNT_PERIOD, periodic_vote_counter)
end
